"use strict";
//
// utilities.ts - utility methods to manipulate SQL statements
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseBooleanToZeroOne = exports.parseBoolean = exports.parseconnectionstring = exports.validateConfiguration = exports.popCallback = exports.getUpdateResults = exports.prepareSql = exports.escapeSqlParameter = exports.getInitializationCommands = exports.anonimizeError = exports.anonimizeCommand = exports.isNode = exports.isBrowser = void 0;
const types_1 = require("./types");
const types_2 = require("./types");
//
// determining running environment, thanks to browser-or-node
// https://www.npmjs.com/package/browser-or-node
//
exports.isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
exports.isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
//
// utility methods
//
/** Messages going to the server are sometimes logged when error conditions occour and need to be stripped of user credentials  */
function anonimizeCommand(message) {
    // hide password in AUTH command if needed
    message = message.replace(/USER \S+/, 'USER ******');
    message = message.replace(/PASSWORD \S+?(?=;)/, 'PASSWORD ******');
    message = message.replace(/HASH \S+?(?=;)/, 'HASH ******');
    return message;
}
exports.anonimizeCommand = anonimizeCommand;
/** Strip message code in error of user credentials */
function anonimizeError(error) {
    if (error === null || error === void 0 ? void 0 : error.message) {
        error.message = anonimizeCommand(error.message);
    }
    return error;
}
exports.anonimizeError = anonimizeError;
/** Initialization commands sent to database when connection is established */
function getInitializationCommands(config) {
    // first user authentication, then all other commands
    let commands = '';
    if (config.apikey) {
        commands = `AUTH APIKEY ${config.apikey}; `;
    }
    else {
        commands = `AUTH USER ${config.username || ''} ${config.password_hashed ? 'HASH' : 'PASSWORD'} ${config.password || ''}; `;
    }
    if (config.database) {
        if (config.create && !config.memory) {
            commands += `CREATE DATABASE ${config.database} IF NOT EXISTS; `;
        }
        commands += `USE DATABASE ${config.database}; `;
    }
    if (config.compression) {
        commands += 'SET CLIENT KEY COMPRESSION TO 1; ';
    }
    if (config.zerotext) {
        commands += 'SET CLIENT KEY ZEROTEXT TO 1; ';
    }
    if (config.non_linearizable) {
        commands += 'SET CLIENT KEY NONLINEARIZABLE TO 1; ';
    }
    if (config.noblob) {
        commands += 'SET CLIENT KEY NOBLOB TO 1; ';
    }
    if (config.maxdata) {
        commands += `SET CLIENT KEY MAXDATA TO ${config.maxdata}; `;
    }
    if (config.maxrows) {
        commands += `SET CLIENT KEY MAXROWS TO ${config.maxrows}; `;
    }
    if (config.maxrowset) {
        commands += `SET CLIENT KEY MAXROWSET TO ${config.maxrowset}; `;
    }
    return commands;
}
exports.getInitializationCommands = getInitializationCommands;
/** Takes a generic value and escapes it so it can replace ? as a binding in a prepared SQL statement */
function escapeSqlParameter(param) {
    if (param === null || param === undefined) {
        return 'NULL';
    }
    if (typeof param === 'string') {
        // replace single quote with two single quotes
        param = param.replace(/'/g, "''");
        return `'${param}'`;
    }
    if (typeof param === 'number' || typeof param === 'bigint') {
        return param.toString();
    }
    if (typeof param === 'boolean') {
        return param ? '1' : '0';
    }
    // serialize buffer as X'...' hex encoded string
    if (Buffer.isBuffer(param)) {
        return `X'${param.toString('hex')}'`;
    }
    if (typeof param === 'object') {
        // serialize json then escape single quotes
        let json = JSON.stringify(param);
        json = json.replace(/'/g, "''");
        return `'${json}'`;
    }
    throw new types_1.SQLiteCloudError(`Unsupported parameter type: ${typeof param}`);
}
exports.escapeSqlParameter = escapeSqlParameter;
/** Take a sql statement and replaces ? or $named parameters that are properly serialized and escaped. */
function prepareSql(sql, ...params) {
    // parameters where passed as an array of parameters?
    if ((params === null || params === void 0 ? void 0 : params.length) === 1 && Array.isArray(params[0])) {
        params = params[0];
    }
    // replace ? or ?idx parameters passed as args or as an array
    let parameterIndex = 1;
    let preparedSql = sql.replace(/\?(\d+)?/g, (match, matchIndex) => {
        const index = matchIndex ? parseInt(matchIndex) : parameterIndex;
        parameterIndex++;
        let sqlParameter;
        if (params[0] && typeof params[0] === 'object' && !(params[0] instanceof Buffer)) {
            sqlParameter = params[0][index];
        }
        if (!sqlParameter) {
            if (index > params.length) {
                throw new types_1.SQLiteCloudError('Not enough parameters');
            }
            sqlParameter = params[index - 1];
        }
        return sqlParameter !== null && sqlParameter !== undefined ? escapeSqlParameter(sqlParameter) : 'NULL';
    });
    // replace $named or :named parameters passed as an object
    if ((params === null || params === void 0 ? void 0 : params.length) === 1 && params[0] && typeof params[0] === 'object') {
        const namedParams = params[0];
        for (const [paramKey, param] of Object.entries(namedParams)) {
            const firstChar = paramKey.charAt(0);
            if (firstChar == '$' || firstChar == ':' || firstChar == '@') {
                const escapedParam = escapeSqlParameter(param);
                preparedSql = preparedSql.replace(new RegExp(`\\${paramKey}`, 'g'), escapedParam);
            }
        }
    }
    return preparedSql;
}
exports.prepareSql = prepareSql;
/** Converts results of an update or insert call into a more meaning full result set */
function getUpdateResults(results) {
    if (results) {
        if (Array.isArray(results) && results.length > 0) {
            switch (results[0]) {
                case types_2.SQLiteCloudArrayType.ARRAY_TYPE_SQLITE_EXEC:
                    return {
                        type: results[0],
                        index: results[1],
                        lastID: results[2],
                        changes: results[3],
                        totalChanges: results[4],
                        finalized: results[5],
                        //
                        rowId: results[2] // same as lastId
                    };
            }
        }
    }
    return undefined;
}
exports.getUpdateResults = getUpdateResults;
/**
 * Many of the methods in our API may contain a callback as their last argument.
 * This method will take the arguments array passed to the method and return an object
 * containing the arguments array with the callbacks removed (if any), and the callback itself.
 * If there are multiple callbacks, the first one is returned as 'callback' and the last one
 * as 'completeCallback'.
 */
function popCallback(args) {
    const remaining = args;
    // at least 1 callback?
    if (args && args.length > 0 && typeof args[args.length - 1] === 'function') {
        // at least 2 callbacks?
        if (args.length > 1 && typeof args[args.length - 2] === 'function') {
            return { args: remaining.slice(0, -2), callback: args[args.length - 2], complete: args[args.length - 1] };
        }
        return { args: remaining.slice(0, -1), callback: args[args.length - 1] };
    }
    return { args: remaining };
}
exports.popCallback = popCallback;
//
// configuration validation
//
/** Validate configuration, apply defaults, throw if something is missing or misconfigured */
function validateConfiguration(config) {
    console.assert(config, 'SQLiteCloudConnection.validateConfiguration - missing config');
    if (config.connectionstring) {
        config = Object.assign(Object.assign(Object.assign({}, config), parseconnectionstring(config.connectionstring)), { connectionstring: config.connectionstring // keep original connection string
         });
    }
    // apply defaults where needed
    config.port || (config.port = types_1.DEFAULT_PORT);
    config.timeout = config.timeout && config.timeout > 0 ? config.timeout : types_1.DEFAULT_TIMEOUT;
    config.clientid || (config.clientid = 'SQLiteCloud');
    config.verbose = parseBoolean(config.verbose);
    config.noblob = parseBoolean(config.noblob);
    config.compression = parseBoolean(config.compression);
    config.create = parseBoolean(config.create);
    config.non_linearizable = parseBoolean(config.non_linearizable);
    config.insecure = parseBoolean(config.insecure);
    const hasCredentials = (config.username && config.password) || config.apikey;
    if (!config.host || !hasCredentials) {
        console.error('SQLiteCloudConnection.validateConfiguration - missing arguments', config);
        throw new types_1.SQLiteCloudError('The user, password and host arguments or the ?apikey= must be specified.', { errorCode: 'ERR_MISSING_ARGS' });
    }
    if (!config.connectionstring) {
        // build connection string from configuration, values are already validated
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        if (config.apikey) {
            config.connectionstring = `sqlitecloud://${config.host}:${config.port}/${config.database || ''}?apikey=${config.apikey}`;
        }
        else {
            config.connectionstring = `sqlitecloud://${encodeURIComponent(config.username || '')}:${encodeURIComponent(config.password || '')}@${config.host}:${config.port}/${config.database}`;
        }
    }
    return config;
}
exports.validateConfiguration = validateConfiguration;
/**
 * Parse connectionstring like sqlitecloud://username:password@host:port/database?option1=xxx&option2=xxx
 * or sqlitecloud://host.sqlite.cloud:8860/chinook.sqlite?apikey=mIiLARzKm9XBVllbAzkB1wqrgijJ3Gx0X5z1Agm3xBo
 * into its basic components.
 */
function parseconnectionstring(connectionstring) {
    try {
        // The URL constructor throws a TypeError if the URL is not valid.
        // in spite of having the same structure as a regular url
        // protocol://username:password@host:port/database?option1=xxx&option2=xxx)
        // the sqlitecloud: protocol is not recognized by the URL constructor in browsers
        // so we need to replace it with https: to make it work
        const knownProtocolUrl = connectionstring.replace('sqlitecloud:', 'https:');
        const url = new URL(knownProtocolUrl);
        // all lowecase options
        const options = {};
        url.searchParams.forEach((value, key) => {
            options[key.toLowerCase().replaceAll('-', '_')] = value;
        });
        const config = Object.assign({ username: decodeURIComponent(url.username), password: decodeURIComponent(url.password), host: url.hostname, port: url.port ? parseInt(url.port) : undefined }, options);
        // either you use an apikey or username and password
        if (config.apikey) {
            if (config.username || config.password) {
                console.warn('SQLiteCloudConnection.parseconnectionstring - apikey and username/password are both specified, using apikey');
            }
            delete config.username;
            delete config.password;
        }
        const database = url.pathname.replace('/', ''); // pathname is database name, remove the leading slash
        if (database) {
            config.database = database;
        }
        return config;
    }
    catch (error) {
        throw new types_1.SQLiteCloudError(`Invalid connection string: ${connectionstring}`);
    }
}
exports.parseconnectionstring = parseconnectionstring;
/** Returns true if value is 1 or true */
function parseBoolean(value) {
    if (typeof value === 'string') {
        return value.toLowerCase() === 'true' || value === '1';
    }
    return value ? true : false;
}
exports.parseBoolean = parseBoolean;
/** Returns true if value is 1 or true */
function parseBooleanToZeroOne(value) {
    if (typeof value === 'string') {
        return value.toLowerCase() === 'true' || value === '1' ? 1 : 0;
    }
    return value ? 1 : 0;
}
exports.parseBooleanToZeroOne = parseBooleanToZeroOne;
