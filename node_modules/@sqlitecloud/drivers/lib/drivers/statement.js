"use strict";
/**
 * statement.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Statement = void 0;
const utilities_1 = require("./utilities");
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/** A statement generated by Database.prepare used to prepare SQL with ? bindings */
class Statement {
    constructor(database, sql, ...params) {
        const { args, callback } = (0, utilities_1.popCallback)(params);
        this._database = database;
        this._sql = sql;
        if ((args === null || args === void 0 ? void 0 : args.length) > 0) {
            this.bind(...args, callback);
        }
        else {
            callback === null || callback === void 0 ? void 0 : callback.call(this, null);
        }
    }
    /**
     * Binds parameters to the prepared statement and calls the callback when done
     * or when an error occurs. The function returns the Statement object to allow
     * for function chaining. The first and only argument to the callback is null
     * when binding was successful, otherwise it is the error object. Binding parameters
     * with this function completely resets the statement object and row cursor and
     * removes all previously bound parameters, if any. Currently bound parameters
     * are escaped client side and turned into literals before being executed on the server.
     */
    bind(...params) {
        const { args, callback } = (0, utilities_1.popCallback)(params);
        try {
            this._preparedSql = (0, utilities_1.prepareSql)(this._sql, ...args);
            if (callback) {
                callback.call(this, null);
            }
        }
        catch (error) {
            this._preparedSql = undefined;
            if (callback) {
                callback.call(this, error);
            }
        }
        return this;
    }
    run(...params) {
        const { args, callback } = (0, utilities_1.popCallback)(params || []);
        if ((args === null || args === void 0 ? void 0 : args.length) > 0) {
            // apply new bindings then execute
            this.bind(...args, (error) => {
                if (error) {
                    callback === null || callback === void 0 ? void 0 : callback.call(this, error);
                }
                else {
                    this._database.run(this._preparedSql || '', callback);
                }
            });
        }
        else {
            // execute prepared sql with same bindings
            this._database.run(this._preparedSql || '', callback);
        }
        return this;
    }
    get(...params) {
        const { args, callback } = (0, utilities_1.popCallback)(params || []);
        if ((args === null || args === void 0 ? void 0 : args.length) > 0) {
            // apply new bindings then execute
            this.bind(...args, (error) => {
                if (error) {
                    callback === null || callback === void 0 ? void 0 : callback.call(this, error);
                }
                else {
                    this._database.get(this._preparedSql || '', callback);
                }
            });
        }
        else {
            // execute prepared sql with same bindings
            this._database.get(this._preparedSql || '', callback);
        }
        return this;
    }
    all(...params) {
        const { args, callback } = (0, utilities_1.popCallback)(params || []);
        if ((args === null || args === void 0 ? void 0 : args.length) > 0) {
            // apply new bindings then execute
            this.bind(...args, (error) => {
                if (error) {
                    callback === null || callback === void 0 ? void 0 : callback.call(this, error);
                }
                else {
                    this._database.all(this._preparedSql || '', callback);
                }
            });
        }
        else {
            // execute prepared sql with same bindings
            this._database.all(this._preparedSql || '', callback);
        }
        return this;
    }
    each(...params) {
        const { args, callback, complete } = (0, utilities_1.popCallback)(params);
        if ((args === null || args === void 0 ? void 0 : args.length) > 0) {
            // apply new bindings then execute
            this.bind(...args, (error) => {
                if (error) {
                    callback === null || callback === void 0 ? void 0 : callback.call(this, error);
                }
                else {
                    this._database.each(this._preparedSql || '', callback, complete);
                }
            });
        }
        else {
            // execute prepared sql with same bindings
            this._database.each(this._preparedSql || '', callback, complete);
        }
        return this;
    }
}
exports.Statement = Statement;
