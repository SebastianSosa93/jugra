"use strict";
//
// protocol.ts - low level protocol handling for SQLiteCloud transport
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatCommand = exports.popData = exports.parseRowsetChunks = exports.bufferEndsWith = exports.bufferStartsWith = exports.parseRowsetHeader = exports.parseArray = exports.parseError = exports.decompressBuffer = exports.parseCommandLength = exports.hasCommandLength = exports.ROWSET_CHUNKS_END = exports.CMD_ARRAY = exports.CMD_COMMAND = exports.CMD_COMPRESSED = exports.CMD_BLOB = exports.CMD_NULL = exports.CMD_JSON = exports.CMD_ROWSET_CHUNK = exports.CMD_ROWSET = exports.CMD_FLOAT = exports.CMD_INT = exports.CMD_ERROR = exports.CMD_ZEROSTRING = exports.CMD_STRING = void 0;
const types_1 = require("./types");
const rowset_1 = require("./rowset");
const lz4 = require('lz4js');
// The server communicates with clients via commands defined in
// SQLiteCloud Server Protocol (SCSP), see more at:
// https://github.com/sqlitecloud/sdk/blob/master/PROTOCOL.md
exports.CMD_STRING = '+';
exports.CMD_ZEROSTRING = '!';
exports.CMD_ERROR = '-';
exports.CMD_INT = ':';
exports.CMD_FLOAT = ',';
exports.CMD_ROWSET = '*';
exports.CMD_ROWSET_CHUNK = '/';
exports.CMD_JSON = '#';
exports.CMD_NULL = '_';
exports.CMD_BLOB = '$';
exports.CMD_COMPRESSED = '%';
exports.CMD_COMMAND = '^';
exports.CMD_ARRAY = '=';
// const CMD_RAWJSON = '{'
// const CMD_PUBSUB = '|'
// const CMD_RECONNECT = '@'
// To mark the end of the Rowset, the special string /LEN 0 0 0   is sent (LEN is always 6 in this case)
// https://github.com/sqlitecloud/sdk/blob/master/PROTOCOL.md#scsp-rowset-chunk
exports.ROWSET_CHUNKS_END = '/6 0 0 0 ';
//
// utility functions
//
/** Analyze first character to check if corresponding data type has LEN */
function hasCommandLength(firstCharacter) {
    return firstCharacter == exports.CMD_INT || firstCharacter == exports.CMD_FLOAT || firstCharacter == exports.CMD_NULL ? false : true;
}
exports.hasCommandLength = hasCommandLength;
/** Analyze a command with explict LEN and extract it */
function parseCommandLength(data) {
    return parseInt(data.subarray(1, data.indexOf(' ')).toString('utf8'));
}
exports.parseCommandLength = parseCommandLength;
/** Receive a compressed buffer, decompress with lz4, return buffer and datatype */
function decompressBuffer(buffer) {
    const spaceIndex = buffer.indexOf(' ');
    buffer = buffer.subarray(spaceIndex + 1);
    // extract compressed size
    const compressedSize = parseInt(buffer.subarray(0, buffer.indexOf(' ') + 1).toString('utf8'));
    buffer = buffer.subarray(buffer.indexOf(' ') + 1);
    // extract decompressed size
    const decompressedSize = parseInt(buffer.subarray(0, buffer.indexOf(' ') + 1).toString('utf8'));
    buffer = buffer.subarray(buffer.indexOf(' ') + 1);
    // extract compressed dataType
    const dataType = buffer.subarray(0, 1).toString('utf8');
    const decompressedBuffer = Buffer.alloc(decompressedSize);
    const compressedBuffer = buffer.subarray(buffer.length - compressedSize);
    // lz4js library is javascript and doesn't have types so we silence the type check
    // eslint-disable-next-line
    const decompressionResult = lz4.decompressBlock(compressedBuffer, decompressedBuffer, 0, compressedSize, 0);
    buffer = Buffer.concat([buffer.subarray(0, buffer.length - compressedSize), decompressedBuffer]);
    if (decompressionResult <= 0 || decompressionResult !== decompressedSize) {
        throw new Error(`lz4 decompression error at offset ${decompressionResult}`);
    }
    return { buffer, dataType };
}
exports.decompressBuffer = decompressBuffer;
/** Parse error message or extended error message */
function parseError(buffer, spaceIndex) {
    const errorBuffer = buffer.subarray(spaceIndex + 1);
    const errorString = errorBuffer.toString('utf8');
    const parts = errorString.split(' ');
    let errorCodeStr = parts.shift() || '0'; // Default errorCode is '0' if not present
    let extErrCodeStr = '0'; // Default extended error code
    let offsetCodeStr = '-1'; // Default offset code
    // Split the errorCode by ':' to check for extended error codes
    const errorCodeParts = errorCodeStr.split(':');
    errorCodeStr = errorCodeParts[0];
    if (errorCodeParts.length > 1) {
        extErrCodeStr = errorCodeParts[1];
        if (errorCodeParts.length > 2) {
            offsetCodeStr = errorCodeParts[2];
        }
    }
    // Rest of the error string is the error message
    const errorMessage = parts.join(' ');
    // Parse error codes to integers safely, defaulting to 0 if NaN
    const errorCode = parseInt(errorCodeStr);
    const extErrCode = parseInt(extErrCodeStr);
    const offsetCode = parseInt(offsetCodeStr);
    // create an Error object and add the custom properties
    throw new types_1.SQLiteCloudError(errorMessage, {
        errorCode: errorCode.toString(),
        externalErrorCode: extErrCode.toString(),
        offsetCode
    });
}
exports.parseError = parseError;
/** Parse an array of items (each of which will be parsed by type separately) */
function parseArray(buffer, spaceIndex) {
    const parsedData = [];
    const array = buffer.subarray(spaceIndex + 1, buffer.length);
    const numberOfItems = parseInt(array.subarray(0, spaceIndex - 2).toString('utf8'));
    let arrayItems = array.subarray(array.indexOf(' ') + 1, array.length);
    for (let i = 0; i < numberOfItems; i++) {
        const { data, fwdBuffer: buffer } = popData(arrayItems);
        parsedData.push(data);
        arrayItems = buffer;
    }
    return parsedData;
}
exports.parseArray = parseArray;
/** Parse header in a rowset or chunk of a chunked rowset */
function parseRowsetHeader(buffer) {
    const index = parseInt(buffer.subarray(0, buffer.indexOf(':') + 1).toString());
    buffer = buffer.subarray(buffer.indexOf(':') + 1);
    // extract rowset header
    const { data, fwdBuffer } = popIntegers(buffer, 3);
    return {
        index,
        metadata: {
            version: data[0],
            numberOfRows: data[1],
            numberOfColumns: data[2],
            columns: []
        },
        fwdBuffer
    };
}
exports.parseRowsetHeader = parseRowsetHeader;
/** Extract column names and, optionally, more metadata out of a rowset's header */
function parseRowsetColumnsMetadata(buffer, metadata) {
    function popForward() {
        const { data, fwdBuffer: fwdBuffer } = popData(buffer); // buffer in parent scope
        buffer = fwdBuffer;
        return data;
    }
    for (let i = 0; i < metadata.numberOfColumns; i++) {
        metadata.columns.push({ name: popForward() });
    }
    // extract additional metadata if rowset has version 2
    if (metadata.version == 2) {
        for (let i = 0; i < metadata.numberOfColumns; i++)
            metadata.columns[i].type = popForward();
        for (let i = 0; i < metadata.numberOfColumns; i++)
            metadata.columns[i].database = popForward();
        for (let i = 0; i < metadata.numberOfColumns; i++)
            metadata.columns[i].table = popForward();
        for (let i = 0; i < metadata.numberOfColumns; i++)
            metadata.columns[i].column = popForward(); // original column name
        for (let i = 0; i < metadata.numberOfColumns; i++)
            metadata.columns[i].notNull = popForward();
        for (let i = 0; i < metadata.numberOfColumns; i++)
            metadata.columns[i].primaryKey = popForward();
        for (let i = 0; i < metadata.numberOfColumns; i++)
            metadata.columns[i].autoIncrement = popForward();
    }
    return buffer;
}
/** Parse a regular rowset (no chunks) */
function parseRowset(buffer, spaceIndex) {
    buffer = buffer.subarray(spaceIndex + 1, buffer.length);
    const { metadata, fwdBuffer } = parseRowsetHeader(buffer);
    buffer = parseRowsetColumnsMetadata(fwdBuffer, metadata);
    // decode each rowset item
    const data = [];
    for (let j = 0; j < metadata.numberOfRows * metadata.numberOfColumns; j++) {
        const { data: rowData, fwdBuffer } = popData(buffer);
        data.push(rowData);
        buffer = fwdBuffer;
    }
    console.assert(data && data.length === metadata.numberOfRows * metadata.numberOfColumns, 'SQLiteCloudConnection.parseRowset - invalid rowset data');
    return new rowset_1.SQLiteCloudRowset(metadata, data);
}
function bufferStartsWith(buffer, prefix) {
    return buffer.length >= prefix.length && buffer.subarray(0, prefix.length).toString('utf8') === prefix;
}
exports.bufferStartsWith = bufferStartsWith;
function bufferEndsWith(buffer, suffix) {
    return buffer.length >= suffix.length && buffer.subarray(buffer.length - suffix.length, buffer.length).toString('utf8') === suffix;
}
exports.bufferEndsWith = bufferEndsWith;
/**
 * Parse a chunk of a chunked rowset command, eg:
 * *LEN 0:VERS NROWS NCOLS DATA
 * @see https://github.com/sqlitecloud/sdk/blob/master/PROTOCOL.md#scsp-rowset-chunk
 */
function parseRowsetChunks(buffers) {
    let buffer = Buffer.concat(buffers);
    if (!bufferStartsWith(buffer, exports.CMD_ROWSET_CHUNK) || !bufferEndsWith(buffer, exports.ROWSET_CHUNKS_END)) {
        throw new Error('SQLiteCloudConnection.parseRowsetChunks - invalid chunks buffer');
    }
    let metadata = { version: 1, numberOfColumns: 0, numberOfRows: 0, columns: [] };
    const data = [];
    // validate and skip data type
    const dataType = buffer.subarray(0, 1).toString();
    console.assert(dataType === exports.CMD_ROWSET_CHUNK);
    buffer = buffer.subarray(buffer.indexOf(' ') + 1);
    while (buffer.length > 0 && !bufferStartsWith(buffer, exports.ROWSET_CHUNKS_END)) {
        // chunk header, eg: 0:VERS NROWS NCOLS
        const { index: chunkIndex, metadata: chunkMetadata, fwdBuffer } = parseRowsetHeader(buffer);
        buffer = fwdBuffer;
        // first chunk? extract columns metadata
        if (chunkIndex === 1) {
            metadata = chunkMetadata;
            buffer = parseRowsetColumnsMetadata(buffer, metadata);
        }
        else {
            metadata.numberOfRows += chunkMetadata.numberOfRows;
        }
        // extract single rowset row
        for (let k = 0; k < chunkMetadata.numberOfRows * metadata.numberOfColumns; k++) {
            const { data: itemData, fwdBuffer } = popData(buffer);
            data.push(itemData);
            buffer = fwdBuffer;
        }
    }
    console.assert(data && data.length === metadata.numberOfRows * metadata.numberOfColumns, 'parseRowsetChunks - invalid rowset data');
    const rowset = new rowset_1.SQLiteCloudRowset(metadata, data);
    // console.debug(`parseRowsetChunks - ${rowset.numberOfRows} rows, ${rowset.numberOfColumns} columns`)
    return rowset;
}
exports.parseRowsetChunks = parseRowsetChunks;
/** Pop one or more space separated integers from beginning of buffer, move buffer forward */
function popIntegers(buffer, numberOfIntegers = 1) {
    const data = [];
    for (let i = 0; i < numberOfIntegers; i++) {
        const spaceIndex = buffer.indexOf(' ');
        data[i] = parseInt(buffer.subarray(0, spaceIndex).toString());
        buffer = buffer.subarray(spaceIndex + 1);
    }
    return { data, fwdBuffer: buffer };
}
/** Parse command, extract its data, return the data and the buffer moved to the first byte after the command */
function popData(buffer) {
    function popResults(data) {
        const fwdBuffer = buffer.subarray(commandEnd);
        return { data, fwdBuffer };
    }
    // first character is the data type
    console.assert(buffer && buffer instanceof Buffer);
    const dataType = buffer.subarray(0, 1).toString('utf8');
    console.assert(dataType !== exports.CMD_COMPRESSED, "Compressed data shouldn't be decompressed before parsing");
    console.assert(dataType !== exports.CMD_ROWSET_CHUNK, 'Chunked data should be parsed by parseRowsetChunks');
    let spaceIndex = buffer.indexOf(' ');
    if (spaceIndex === -1) {
        spaceIndex = buffer.length - 1;
    }
    let commandEnd = -1;
    if (dataType === exports.CMD_INT || dataType === exports.CMD_FLOAT || dataType === exports.CMD_NULL) {
        commandEnd = spaceIndex + 1;
    }
    else {
        const commandLength = parseInt(buffer.subarray(1, spaceIndex).toString());
        commandEnd = spaceIndex + 1 + commandLength;
    }
    switch (dataType) {
        case exports.CMD_INT:
            return popResults(parseInt(buffer.subarray(1, spaceIndex).toString()));
        case exports.CMD_FLOAT:
            return popResults(parseFloat(buffer.subarray(1, spaceIndex).toString()));
        case exports.CMD_NULL:
            return popResults(null);
        case exports.CMD_STRING:
            return popResults(buffer.subarray(spaceIndex + 1, commandEnd).toString('utf8'));
        case exports.CMD_ZEROSTRING:
            return popResults(buffer.subarray(spaceIndex + 1, commandEnd - 1).toString('utf8'));
        case exports.CMD_COMMAND:
            return popResults(buffer.subarray(spaceIndex + 1, commandEnd).toString('utf8'));
        case exports.CMD_JSON:
            return popResults(JSON.parse(buffer.subarray(spaceIndex + 1, commandEnd).toString('utf8')));
        case exports.CMD_BLOB:
            return popResults(buffer.subarray(spaceIndex + 1, commandEnd));
        case exports.CMD_ARRAY:
            return popResults(parseArray(buffer, spaceIndex));
        case exports.CMD_ROWSET:
            return popResults(parseRowset(buffer, spaceIndex));
        case exports.CMD_ERROR:
            parseError(buffer, spaceIndex); // throws custom error
            break;
    }
    throw new TypeError(`Data type: ${dataType} is not defined in SCSP`);
}
exports.popData = popData;
/** Format a command to be sent via SCSP protocol */
function formatCommand(command) {
    const commandLength = Buffer.byteLength(command, 'utf-8');
    return `+${commandLength} ${command}`;
}
exports.formatCommand = formatCommand;
