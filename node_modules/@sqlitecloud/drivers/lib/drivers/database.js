"use strict";
//
// database.ts - database driver api, implements and extends sqlite3
//
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Database = void 0;
const rowset_1 = require("./rowset");
const types_1 = require("./types");
const utilities_1 = require("./utilities");
const statement_1 = require("./statement");
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const utilities_2 = require("./utilities");
// Uses eventemitter3 instead of node events for browser compatibility
// https://github.com/primus/eventemitter3
/**
 * Creating a Database object automatically opens a connection to the SQLite database.
 * When the connection is established the Database object emits an open event and calls
 * the optional provided callback. If the connection cannot be established an error event
 * will be emitted and the optional callback is called with the error information.
 */
class Database extends eventemitter3_1.default {
    constructor(config, mode, callback) {
        super();
        /** Database connections */
        this.connections = [];
        this.config = typeof config === 'string' ? { connectionstring: config } : config;
        // mode is optional and so is callback
        // https://github.com/TryGhost/node-sqlite3/wiki/API#new-sqlite3databasefilename--mode--callback
        if (typeof mode === 'function') {
            callback = mode;
            mode = undefined;
        }
        // mode is ignored for now
        // opens first connection to the database automatically
        this.getConnection((error, _connection) => {
            if (callback) {
                callback.call(this, error);
            }
        });
    }
    //
    // private methods
    //
    /** Returns first available connection from connection pool */
    getConnection(callback) {
        var _a, _b, _c;
        // TODO sqlitecloud-js / implement database connection pool #10
        if (((_a = this.connections) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            callback === null || callback === void 0 ? void 0 : callback.call(this, null, this.connections[0]);
        }
        else {
            // connect using websocket if tls is not supported or if explicitly requested
            const useWebsocket = utilities_2.isBrowser || ((_b = this.config) === null || _b === void 0 ? void 0 : _b.usewebsocket) || ((_c = this.config) === null || _c === void 0 ? void 0 : _c.gatewayurl);
            if (useWebsocket) {
                // socket.io transport works in both node.js and browser environments and connects via SQLite Cloud Gateway
                Promise.resolve().then(() => __importStar(require('./connection-ws'))).then(module => {
                    this.connections.push(new module.default(this.config, error => {
                        if (error) {
                            this.handleError(this.connections[0], error, callback);
                        }
                        else {
                            console.assert;
                            callback === null || callback === void 0 ? void 0 : callback.call(this, null, this.connections[0]);
                            this.emitEvent('open');
                        }
                    }));
                })
                    .catch(error => {
                    this.handleError(null, error, callback);
                });
            }
            else {
                // tls sockets work only in node.js environments
                Promise.resolve().then(() => __importStar(require('./connection-tls'))).then(module => {
                    this.connections.push(new module.default(this.config, error => {
                        if (error) {
                            this.handleError(this.connections[0], error, callback);
                        }
                        else {
                            console.assert;
                            callback === null || callback === void 0 ? void 0 : callback.call(this, null, this.connections[0]);
                            this.emitEvent('open');
                        }
                    }));
                })
                    .catch(error => {
                    this.handleError(null, error, callback);
                });
            }
        }
    }
    /** Handles an error by closing the connection, calling the callback and/or emitting an error event */
    handleError(connection, error, callback) {
        // an errored connection is thrown out
        if (connection) {
            this.connections = this.connections.filter(c => c !== connection);
            connection.close();
        }
        if (callback) {
            callback.call(this, error);
        }
        else {
            this.emitEvent('error', error);
        }
    }
    /**
     * Some queries like inserts or updates processed via run or exec may generate
     * an empty result (eg. no data was selected), but still have some metadata.
     * For example the server may pass the id of the last row that was modified.
     * In this case the callback results should be empty but the context may contain
     * additional information like lastID, etc.
     * @see https://github.com/TryGhost/node-sqlite3/wiki/API#runsql--param---callback
     * @param results Results received from the server
     * @returns A context object if one makes sense, otherwise undefined
     */
    processContext(results) {
        if (results) {
            if (Array.isArray(results) && results.length > 0) {
                switch (results[0]) {
                    case types_1.SQLiteCloudArrayType.ARRAY_TYPE_SQLITE_EXEC:
                        return {
                            lastID: results[2],
                            changes: results[3],
                            totalChanges: results[4],
                            finalized: results[5] // FINALIZED
                        };
                }
            }
        }
        return undefined;
    }
    /** Emits given event with optional arguments on the next tick so callbacks can complete first */
    emitEvent(event, ...args) {
        setTimeout(() => {
            this.emit(event, ...args);
        }, 0);
    }
    //
    // public methods
    //
    /**
     * Returns the configuration with which this database was opened.
     * The configuration is readonly and cannot be changed as there may
     * be multiple connections using the same configuration.
     * @returns {SQLiteCloudConfig} A configuration object
     */
    getConfiguration() {
        return JSON.parse(JSON.stringify(this.config));
    }
    /** Enable verbose mode */
    verbose() {
        this.config.verbose = true;
        for (const connection of this.connections) {
            connection.verbose();
        }
        return this;
    }
    /** Set a configuration option for the database */
    configure(_option, _value) {
        // https://github.com/TryGhost/node-sqlite3/wiki/API#configureoption-value
        return this;
    }
    run(sql, ...params) {
        const { args, callback } = (0, utilities_1.popCallback)(params);
        const preparedSql = (args === null || args === void 0 ? void 0 : args.length) > 0 ? (0, utilities_1.prepareSql)(sql, ...args) : sql;
        this.getConnection((error, connection) => {
            if (error || !connection) {
                this.handleError(null, error, callback);
            }
            else {
                connection.sendCommands(preparedSql, (error, results) => {
                    if (error) {
                        this.handleError(connection, error, callback);
                    }
                    else {
                        // context may include id of last row inserted, total changes, etc...
                        const context = this.processContext(results);
                        callback === null || callback === void 0 ? void 0 : callback.call(context || this, null, context ? context : results);
                    }
                });
            }
        });
        return this;
    }
    get(sql, ...params) {
        const { args, callback } = (0, utilities_1.popCallback)(params);
        const preparedSql = (args === null || args === void 0 ? void 0 : args.length) > 0 ? (0, utilities_1.prepareSql)(sql, ...args) : sql;
        this.getConnection((error, connection) => {
            if (error || !connection) {
                this.handleError(null, error, callback);
            }
            else {
                connection.sendCommands(preparedSql, (error, results) => {
                    if (error) {
                        this.handleError(connection, error, callback);
                    }
                    else {
                        if (results && results instanceof rowset_1.SQLiteCloudRowset && results.length > 0) {
                            callback === null || callback === void 0 ? void 0 : callback.call(this, null, results[0]);
                        }
                        else {
                            callback === null || callback === void 0 ? void 0 : callback.call(this, null);
                        }
                    }
                });
            }
        });
        return this;
    }
    all(sql, ...params) {
        const { args, callback } = (0, utilities_1.popCallback)(params);
        const preparedSql = (args === null || args === void 0 ? void 0 : args.length) > 0 ? (0, utilities_1.prepareSql)(sql, ...args) : sql;
        this.getConnection((error, connection) => {
            if (error || !connection) {
                this.handleError(null, error, callback);
            }
            else {
                connection.sendCommands(preparedSql, (error, results) => {
                    if (error) {
                        this.handleError(connection, error, callback);
                    }
                    else {
                        if (results && results instanceof rowset_1.SQLiteCloudRowset) {
                            callback === null || callback === void 0 ? void 0 : callback.call(this, null, results);
                        }
                        else {
                            callback === null || callback === void 0 ? void 0 : callback.call(this, null);
                        }
                    }
                });
            }
        });
        return this;
    }
    each(sql, ...params) {
        // extract optional parameters and one or two callbacks
        const { args, callback, complete } = (0, utilities_1.popCallback)(params);
        const preparedSql = (args === null || args === void 0 ? void 0 : args.length) > 0 ? (0, utilities_1.prepareSql)(sql, ...args) : sql;
        this.getConnection((error, connection) => {
            if (error || !connection) {
                this.handleError(null, error, callback);
            }
            else {
                connection.sendCommands(preparedSql, (error, rowset) => {
                    if (error) {
                        this.handleError(connection, error, callback);
                    }
                    else {
                        if (rowset && rowset instanceof rowset_1.SQLiteCloudRowset) {
                            if (callback) {
                                for (const row of rowset) {
                                    callback.call(this, null, row);
                                }
                            }
                            if (complete) {
                                ;
                                complete.call(this, null, rowset.numberOfRows);
                            }
                        }
                        else {
                            callback === null || callback === void 0 ? void 0 : callback.call(this, new types_1.SQLiteCloudError('Invalid rowset'));
                        }
                    }
                });
            }
        });
        return this;
    }
    /**
     * Prepares the SQL statement and optionally binds the specified parameters and
     * calls the callback when done. The function returns a Statement object.
     * When preparing was successful, the first and only argument to the callback
     * is null, otherwise it is the error object. When bind parameters are supplied,
     * they are bound to the prepared statement before calling the callback.
     */
    prepare(sql, ...params) {
        const { args, callback } = (0, utilities_1.popCallback)(params);
        return new statement_1.Statement(this, sql, ...args, callback);
    }
    /**
     * Runs all SQL queries in the supplied string. No result rows are retrieved.
     * The function returns the Database object to allow for function chaining.
     * If a query fails, no subsequent statements will be executed (wrap it in a
     * transaction if you want all or none to be executed). When all statements
     * have been executed successfully, or when an error occurs, the callback
     * function is called, with the first parameter being either null or an error
     * object. When no callback is provided and an error occurs, an error event
     * will be emitted on the database object.
     */
    exec(sql, callback) {
        this.getConnection((error, connection) => {
            if (error || !connection) {
                this.handleError(null, error, callback);
            }
            else {
                connection.sendCommands(sql, (error, results) => {
                    if (error) {
                        this.handleError(connection, error, callback);
                    }
                    else {
                        const context = this.processContext(results);
                        callback === null || callback === void 0 ? void 0 : callback.call(context ? context : this, null);
                    }
                });
            }
        });
        return this;
    }
    /**
     * If the optional callback is provided, this function will be called when the
     * database was closed successfully or when an error occurred. The first argument
     * is an error object. When it is null, closing succeeded. If no callback is provided
     * and an error occurred, an error event with the error object as the only parameter
     * will be emitted on the database object. If closing succeeded, a close event with no
     * parameters is emitted, regardless of whether a callback was provided or not.
     */
    close(callback) {
        var _a;
        if (((_a = this.connections) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            for (const connection of this.connections) {
                connection.close();
            }
        }
        callback === null || callback === void 0 ? void 0 : callback.call(this, null);
        this.emitEvent('close');
    }
    /**
     * Loads a compiled SQLite extension into the database connection object.
     * @param path Filename of the extension to load.
     * @param callback  If provided, this function will be called when the extension
     * was loaded successfully or when an error occurred. The first argument is an
     * error object. When it is null, loading succeeded. If no callback is provided
     * and an error occurred, an error event with the error object as the only parameter
     * will be emitted on the database object.
     */
    loadExtension(_path, callback) {
        // TODO sqlitecloud-js / implement database loadExtension #17
        if (callback) {
            callback.call(this, new Error('Database.loadExtension - Not implemented'));
        }
        else {
            this.emitEvent('error', new Error('Database.loadExtension - Not implemented'));
        }
        return this;
    }
    /**
     * Allows the user to interrupt long-running queries. Wrapper around
     * sqlite3_interrupt and causes other data-fetching functions to be
     * passed an err with code = sqlite3.INTERRUPT. The database must be
     * open to use this function.
     */
    interrupt() {
        // TODO sqlitecloud-js / implement database interrupt #13
    }
    //
    // extended APIs
    //
    /**
     * Sql is a promise based API for executing SQL statements. You can
     * pass a simple string with a SQL statement or a template string
     * using backticks and parameters in ${parameter} format. These parameters
     * will be properly escaped and quoted like when using a prepared statement.
     * @param sql A sql string or a template string in `backticks` format
     * @returns An array of rows in case of selections or an object with
     * metadata in case of insert, update, delete.
     */
    sql(sql, ...values) {
        return __awaiter(this, void 0, void 0, function* () {
            let preparedSql = '';
            // sql is a TemplateStringsArray, the 'raw' property is specific to TemplateStringsArray
            if (Array.isArray(sql) && 'raw' in sql) {
                sql.forEach((string, i) => {
                    preparedSql += string + (i < values.length ? '?' : '');
                });
                preparedSql = (0, utilities_1.prepareSql)(preparedSql, ...values);
            }
            else {
                if (typeof sql === 'string') {
                    if ((values === null || values === void 0 ? void 0 : values.length) > 0) {
                        preparedSql = (0, utilities_1.prepareSql)(sql, ...values);
                    }
                    else {
                        preparedSql = sql;
                    }
                }
                else {
                    throw new Error('Invalid sql');
                }
            }
            return new Promise((resolve, reject) => {
                this.getConnection((error, connection) => {
                    if (error || !connection) {
                        reject(error);
                    }
                    else {
                        connection.sendCommands(preparedSql, (error, results) => {
                            if (error) {
                                reject(error);
                            }
                            else {
                                // metadata for operations like insert, update, delete?
                                const context = this.processContext(results);
                                resolve(context ? context : results);
                            }
                        });
                    }
                });
            });
        });
    }
}
exports.Database = Database;
